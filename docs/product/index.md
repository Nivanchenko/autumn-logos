# autumn-logos - Компонент ОСени, для внедрения логгера. 

Компонент [ОСени](https://github.com/autumn-library/autumn) для внедрения [логгера](https://github.com/oscript-library/logos). Удобная аннотация - обертка для получения объекта логгера.

## Подключение

```bsl
#Использовать autumn
#Использовать autumn-logos

// теперь вам доступны логгеры
```

## Использование. 

Допустим у вас есть ```Желудь```. В его поле вы можете внедрить класс ```Лог``` из библиотеки [logos](https://github.com/oscript-library/logos). Внедрение осуществляется по всем правилам ```Пластилина```

Для внедрения используется аннотация ```&Лог("Префикс.библиотеки")```. Аннотация имеет один параметр, содержащий префикс. Допускается также использование аннотации без параметра.

Результатом внедрения будет объект типа ```Лог```. Общая логика такая: 

```Лог = Логирование.ПолучитьЛог(ПереданныйПрефикс + "." + ИмяКлассаВКоторыйВнедряетсяЛог)```

У аннотации ```Лог``` есть второй параметр, который отключает добавление имени класса в конце. И аннотация имеет вид ```&Лог(Значение = "Префикс.библиотеки", УчитыватьИмяКласса = Ложь)```.

```bsl
&Лог(Значение = "my.logger.DEBUG", УчитыватьИмяКласса = Ложь)
Перем ЛогБезИмениКлассаСДебагом;
```

## Пример:

```Файл: МойКласс.os```

```bsl
&Лог(Значение = "Префикс.Лог.БезИмениКласса", УчитыватьИмяКласса = Ложь)
Перем ЛогБезИмениКласса;

&Лог("Префикс.Лог.ВЭкспортромПоле")
Перем ЭкспортныйЛог Экспорт;

&Лог // лог без префикса
Перем ЛогБезПрефикса Экспорт;

Перем _ПриватныйЛог;
Перем ЛогСеттером;

&Желудь
Процедура ПриСозданииОбъекта(
	&Лог("Префикс.Лог.ВКонструкторе") ЛогВКонструкторе
	)
	_ПриватныйЛог = ЛогВКонструкторе;
КонецПроцедуры

Функция ПриватныйЛог() Экспорт
	Возврат _ПриватныйЛог;
КонецФункции

&Лог("Префикс.Лог.ВСеттере")
Процедура УстановитьЛогСеттером(Значение) Экспорт
	ЛогСеттером = Значение;
КонецПроцедуры

Функция ПолучитьЛогСеттером() Экспорт
	Возврат ЛогСеттером;
КонецФункции
```

## Конфигурирование

Настройка логов осуществляется через файл ```autumn-properties.json``` или ```autumn-properties.yaml```. Структура настроек очень близка к оригинальной библиотеке [logos](https://github.com/oscript-library/logos).

```json
{
    "logos": {
      "logger": { // Описание уровней логов, и ссылки на применяемые аппендеры.
        "rootLogger": {"level":"WARN"},
        "my.logger.DEBUG": "DEBUG", // Уровень можно задать как строкой, так и объектом с ключем level
        "my.logger.INFO": "INFO",
        "my.logger.WARN": {"level":"WARN"},
        "my.logger.stringlayout": {"level":"INFO", "stringlayout":"%ДатаВремя%:%Уровень% - %Сообщение%"},
        "my.logger.classlayout": {"level":"INFO", "classlayout":"МойКлассРаскладки"},
        "my.logger.standartlayout": {"level":"INFO", "classlayout":"ОсновнаяРаскладкаСообщения"},
        "my.logger.jsonlayout": {"level":"INFO", "classlayout":"JSONРаскладкаСообщения"},
        "my.logger.ERROR": {"level":"ERROR"},
        "my.logger.CRITICALERROR": {"level":"CRITICALERROR"},
        "my.logger.DISABLE": {"level":"DISABLE"},
        "my.logger.DEFAULT": {"level":"DEFAULT"},
        "my.logger.fileappender": {"level":"DEBUG", "appenders": ["debugfile", "consoledebug"]}, // Аппендеры можно задать массиом
        "my.logger.consoleappender": {"level":"INFO", "appenders": "debugfile, consoledebug"}    // Или строкой через ","
     },
     "appender": { // Настройки аппендеров
         "debugfile": {
             "type": "ВыводЛогаВФайл",
             "level": "DEBUG",
             "file": "tests/log/fileappender.log"
         },
         "consoledebug": {
            "type": "ВыводЛогаВКонсоль",
            "level": "DEBUG"
        }
     }
    } 
  }
```

Можно задать раскладку одним из двух способов. Ключем ```stringlayout``` где можно задать строку для раскладки по APIv1. Допустимые переменные ```%ДатаВремя%```, ```%Уровень%```, ```%Сообщение%"```. Или указать имя класса, который является желудем в контексте Поделки, и отвечает требованиям APIv2. Пример:

```bsl
&Желудь
&Прозвище("РаскладкаЛогоса")
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Функция ПолучитьФорматированноеСообщение(Знач СобытиеЛога) Экспорт
   
	ФорматированноеСообщение = СобытиеЛога.ПолучитьСообщение();
 
	Возврат ФорматированноеСообщение;
 
КонецФункции
```

## Применение для конфигурирования.

Так же можно применять библиотеку для конфигурирования логов, но без внедрения непосредственно через пластилин. 

```bsl
#Использовать autumn
#Использовать autumn-logos

// Инициализация контекста осени. В этот момент будут произведены настройки логов из файла autumn-properties.json или autumn-properties.yaml
Поделка = Новый Поделка(); 

// Получение настроенного лога.
ЛогОтладка = Логирование.ПолучитьЛог("my.logger.DEBUG"); 
```

## Трюк с мета-аннотациями.

Допустим, я не хочу в каждой аннотации писать имя лога. Тем более, если он одинаковый. Тогда можно сделать аннотацию, которая будет это делать за вас. Вот пример такой аннотации.

```bsl
&Аннотация("ЛогМоейЛибы")
&Лог("oscript.lib.myliba")
Процедура ПриСозданииОбъекта()
КонецПроцедуры
```

И теперь в любом классе можно инжектить уже своей аннотацией.

```bsl
&ЛогМоейЛибы
Перем ЛогЧерезАннотацию;

&Желудь
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура ПолезнаяНагрузка()
  ЛогЧерезАннотацию.Информация("Совершили полезное действие");
КонецПроцедуры
```
